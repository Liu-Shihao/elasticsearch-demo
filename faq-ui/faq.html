<!DOCTYPE html>
<html>

<head>
    <title>FAQ Page</title>
    <meta charset="UTF-8">
</head>
<style>
    em.highlight {
        background-color: yellow;
    }
</style>

<body>

    <h1>Frequently Asked Questions</h1>

    <form id="searchForm">
        <input type="text" id="searchQuery" name="query" placeholder="Enter your search query">
        <button type="submit">Search</button>
    </form>

    <div id="searchResults">
        <!-- Search results will be displayed here -->


    </div>

    <h2 id="faq-1">FAQ 1: What is a Service Mesh?</h2>
    <p>Modern applications are typically architected as distributed collections of microservices, with each collection
        of microservices performing some discrete business function. A service mesh is a dedicated infrastructure layer
        that you can add to your applications. It allows you to transparently add capabilities like observability,
        traffic management, and security, without adding them to your own code. The term “service mesh” describes both
        the type of software you use to implement this pattern, and the security or network domain that is created when
        you use that software.\n\nAs the deployment of distributed services, such as in a Kubernetes-based system, grows
        in size and complexity, it can become harder to understand and manage. Its requirements can include discovery,
        load balancing, failure recovery, metrics, and monitoring. A service mesh also often addresses more complex
        operational requirements, like A/B testing, canary deployments, rate limiting, access control, encryption, and
        end-to-end authentication.\n\nService-to-service communication is what makes a distributed application possible.
        Routing this communication, both within and across application clusters, becomes increasingly complex as the
        number of services grow. Istio helps reduce this complexity while easing the strain on development teams.</p>

    <h2 id="faq-2">FAQ 2: What is Istio?</h2>
    <p>Istio is an open source service mesh that layers transparently onto existing distributed applications. Istio’s
        powerful features provide a uniform and more efficient way to secure, connect, and monitor services. Istio is
        the path to load balancing, service-to-service authentication, and monitoring – with few or no service code
        changes. Its powerful control plane brings vital features, including:\n\nSecure service-to-service communication
        in a cluster with TLS encryption, strong identity-based authentication and authorization\nAutomatic load
        balancing for HTTP, gRPC, WebSocket, and TCP traffic\nFine-grained control of traffic behavior with rich routing
        rules, retries, failovers, and fault injection\nA pluggable policy layer and configuration API supporting access
        controls, rate limits and quotas\nAutomatic metrics, logs, and traces for all traffic within a cluster,
        including cluster ingress and egress\nIstio is designed for extensibility and can handle a diverse range of
        deployment needs. Istio’s control plane runs on Kubernetes, and you can add applications deployed in that
        cluster to your mesh, extend the mesh to other clusters, or even connect VMs or other endpoints running outside
        of Kubernetes.\n\nA large ecosystem of contributors, partners, integrations, and distributors extend and
        leverage Istio for a wide variety of scenarios. You can install Istio yourself, or a number of vendors have
        products that integrate Istio and manage it for you.</p>

    <h2 id="faq-3">FAQ 3: How Istio Works</h2>
    <p>Istio has two components: the data plane and the control plane.\n\nThe data plane is the communication between
        services. Without a service mesh, the network doesn’t understand the traffic being sent over, and can’t make any
        decisions based on what type of traffic it is, or who it is from or to.\n\nService mesh uses a proxy to
        intercept all your network traffic, allowing a broad set of application-aware features based on configuration
        you set.\n\nAn Envoy proxy is deployed along with each service that you start in your cluster, or runs alongside
        services running on VMs.\n\nThe control plane takes your desired configuration, and its view of the services,
        and dynamically programs the proxy servers, updating them as the rules or the environment changes.</p>

    <!-- More FAQ sections can be added here -->

    <h2 id="faq-4">FAQ 4: Why would I want to use Istio?</h2>
    <p>Traditionally, much of the logic handled by Istio has been built directly into applications. Across a fleet of
        services, managing updates to this communications logic can be a large burden. Istio provides an
        infrastructure-level solution to managing service communications.\n\nApplication developers: With Istio managing
        how traffic flows across their services, developers can focus exclusively on business logic and iterate quickly
        on new features.\n\nService operators: Istio enables policy enforcement and mesh monitoring from a single
        centralized control point, independent of application evolution. As a result, operators can ensure continuous
        policy compliance through a simplified management plane.</p>

    <h2 id="faq-5">FAQ 5: How do I get started using Istio?</h2>
    <p>We recommend following the instructions on the getting started page, which installs a demonstration configuration
        along with Istio’s premier sample application, Bookinfo. You can then use this setup to walk through various
        Istio guides that showcase intelligent routing, policy enforcement, security, telemetry, etc., in a tutorial
        style.\n\nTo start using Istio with production Kubernetes deployments, please refer to our deployment models
        documentation and the which Istio installation method should I use? FAQ page.</p>

    <!-- More FAQ sections can be added here -->

    <h2 id="faq-6">FAQ 6: How was Istio started?</h2>
    <p>The Istio project was started by teams from Google and IBM in partnership with the Envoy team from Lyft. It’s
        been developed fully in the open on GitHub."},
        {"id":"faq-7","question":"What deployment environments are supported?","answer":"Istio is designed to be
        platform-independent, initially focused on Kubernetes. For our 1.18 release, Istio supports environments running
        Kubernetes (1.24, 1.25, 1.26, 1.27).</p>

    <h2 id="faq-7">FAQ 7: What is the purpose of anchors in SEO?</h2>
    <p>Anchors can be used to create user-friendly navigation menus...</p>

    <!-- More FAQ sections can be added here -->
    <h2 id="faq-8">FAQ 8: How can I contribute?</h2>
    <p> Contributions are highly welcome. We look forward to community feedback, additions, and bug reports.\n\nThe code
        repositories are hosted on GitHub. Please see our Contribution Guidelines to learn how to contribute.\n\nIn
        addition to the code, there are other ways to contribute to the Istio community, including on our discussion
        forum, Slack, and Stack Overflow.</p>


    <h2 id="faq-9">FAQ 9: Where is the documentation?</h2>
    <p>Check out the documentation right here on istio.io. The docs include concept overviews, task guides, examples,
        and the complete reference documentation.\n\nDetailed developer-level documentation is maintained on our Wiki
    </p>
    <h2 id="faq-10">FAQ 10: Kubernetes - How can I debug problems with automatic sidecar injection?</h2>
    <p>Ensure that your cluster has met the prerequisites for the automatic sidecar injection. If your microservice is
        deployed in kube-system, kube-public or istio-system namespaces, they are exempted from automatic sidecar
        injection. Please use a different namespace instead.</p>
    <h2 id="faq-11">FAQ 11: Can I enable mutual TLS for some services while leaving it disabled for other services in
        the same cluster?</h2>
    <p>Authentication policy can be mesh-wide (which affects all services in the mesh), namespace-wide (all services in
        the same namespace), or service specific. You can have policy or policies to set up mutual TLS for services in a
        cluster in any way as you want.</p>
    <h2 id="faq-12">FAQ 12: How can I verify that traffic is using mutual TLS encryption?</h2>
    <p>If you installed Istio with values.global.proxy.privileged=true, you can use tcpdump to determine encryption
        status. Also in Kubernetes 1.23 and later, as an alternative to installing Istio as privileged, you can use
        kubectl debug to run tcpdump in an ephemeral container. See Istio mutual TLS migration for instructions.</p>

    <h2 id="faq-12">FAQ 13: How does distributed tracing work with Istio?</h2>
    <p>Istio integrates with distributed tracing systems using Envoy-based tracing. With Envoy-based tracing
        integration, applications are responsible for forwarding tracing headers for subsequent outgoing
        requests.\n\nYou can find additional information in the Istio Distributed Tracing (Jaeger, Lightstep, Zipkin)
        Tasks and in the Envoy tracing docs.</p>

    <h2 id="faq-12">FAQ 14: How can I view the current route rules I have configured with Istio?</h2>
    <p>Rules can be viewed using kubectl get virtualservice -o yaml</p>


    <a href="#faq-2">Jump to FAQ 2</a>

    <script>
        const searchForm = document.getElementById('searchForm');
        const searchQueryInput = document.getElementById('searchQuery');
        const searchResultsDiv = document.getElementById('searchResults');

        searchForm.addEventListener('submit', async (e) => {
            e.preventDefault();

            const query = searchQueryInput.value;

            // Send search request to backend API
            try {
                const response = await fetch(`http://localhost:8080/search?q=${query}`);
                const data = await response.json();
                console.log(data)
                // Display search results
                displaySearchResults(data);
            } catch (error) {
                console.error('Error fetching search results:', error);
            }
        });

        function displaySearchResults(results) {
            searchResultsDiv.innerHTML = ''; // Clear previous results

            if (results.length === 0) {
                searchResultsDiv.innerHTML = '<p>No results found.</p>';
                return;
            }

            // searchResults.innerHTML = highlightedQuestion;
            // searchResults.querySelectorAll('em').forEach(em => {
            //     em.classList.add('highlight');
            // });

            const highlightedQuestion = results.data[0].highlight.question[0];
            console.log(highlightedQuestion)
            const emTagContents = highlightedQuestion.match(/<em>(.*?)<\/em>/g).map(tag => tag.replace(/<\/?em>/g, ""));
            console.log(emTagContents)
            
            let textContent = document.getElementById(results.data[0].id).innerHTML;
            // 在原文中搜索匹配的文本并用 <mark> 标签包裹起来
            emTagContents.forEach(content => {
                const pattern = new RegExp(content, 'g');
                textContent = textContent.replace(pattern, `<em class='highlight'>$&</em>`);
            });

            // 将处理后的内容放回页面的 HTML 中
            document.getElementById(results.data[0].id).innerHTML = textContent;


            window.location.href = 'http://localhost:3000/#' + results.data[0].id;
        }
    </script>
</body>

</html>