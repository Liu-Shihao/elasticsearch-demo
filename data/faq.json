[
  {"id":"faq-1","question":"What is a Service Mesh?","answer":"Modern applications are typically architected as distributed collections of microservices, with each collection of microservices performing some discrete business function. A service mesh is a dedicated infrastructure layer that you can add to your applications. It allows you to transparently add capabilities like observability, traffic management, and security, without adding them to your own code. The term “service mesh” describes both the type of software you use to implement this pattern, and the security or network domain that is created when you use that software.\n\nAs the deployment of distributed services, such as in a Kubernetes-based system, grows in size and complexity, it can become harder to understand and manage. Its requirements can include discovery, load balancing, failure recovery, metrics, and monitoring. A service mesh also often addresses more complex operational requirements, like A/B testing, canary deployments, rate limiting, access control, encryption, and end-to-end authentication.\n\nService-to-service communication is what makes a distributed application possible. Routing this communication, both within and across application clusters, becomes increasingly complex as the number of services grow. Istio helps reduce this complexity while easing the strain on development teams."},
  {"id":"faq-2","question":"What is Istio?","answer":"Istio is an open source service mesh that layers transparently onto existing distributed applications. Istio’s powerful features provide a uniform and more efficient way to secure, connect, and monitor services. Istio is the path to load balancing, service-to-service authentication, and monitoring – with few or no service code changes. Its powerful control plane brings vital features, including:\n\nSecure service-to-service communication in a cluster with TLS encryption, strong identity-based authentication and authorization\nAutomatic load balancing for HTTP, gRPC, WebSocket, and TCP traffic\nFine-grained control of traffic behavior with rich routing rules, retries, failovers, and fault injection\nA pluggable policy layer and configuration API supporting access controls, rate limits and quotas\nAutomatic metrics, logs, and traces for all traffic within a cluster, including cluster ingress and egress\nIstio is designed for extensibility and can handle a diverse range of deployment needs. Istio’s control plane runs on Kubernetes, and you can add applications deployed in that cluster to your mesh, extend the mesh to other clusters, or even connect VMs or other endpoints running outside of Kubernetes.\n\nA large ecosystem of contributors, partners, integrations, and distributors extend and leverage Istio for a wide variety of scenarios. You can install Istio yourself, or a number of vendors have products that integrate Istio and manage it for you."},
  {"id":"faq-3","question":"WHow Istio Works","answer":"Istio has two components: the data plane and the control plane.\n\nThe data plane is the communication between services. Without a service mesh, the network doesn’t understand the traffic being sent over, and can’t make any decisions based on what type of traffic it is, or who it is from or to.\n\nService mesh uses a proxy to intercept all your network traffic, allowing a broad set of application-aware features based on configuration you set.\n\nAn Envoy proxy is deployed along with each service that you start in your cluster, or runs alongside services running on VMs.\n\nThe control plane takes your desired configuration, and its view of the services, and dynamically programs the proxy servers, updating them as the rules or the environment changes."},
  {"id":"faq-4","question":"Why would I want to use Istio?","answer":"Traditionally, much of the logic handled by Istio has been built directly into applications. Across a fleet of services, managing updates to this communications logic can be a large burden. Istio provides an infrastructure-level solution to managing service communications.\n\nApplication developers: With Istio managing how traffic flows across their services, developers can focus exclusively on business logic and iterate quickly on new features.\n\nService operators: Istio enables policy enforcement and mesh monitoring from a single centralized control point, independent of application evolution. As a result, operators can ensure continuous policy compliance through a simplified management plane."},
  {"id":"faq-5","question":"How do I get started using Istio?","answer":"We recommend following the instructions on the getting started page, which installs a demonstration configuration along with Istio’s premier sample application, Bookinfo. You can then use this setup to walk through various Istio guides that showcase intelligent routing, policy enforcement, security, telemetry, etc., in a tutorial style.\n\nTo start using Istio with production Kubernetes deployments, please refer to our deployment models documentation and the which Istio installation method should I use? FAQ page."},
  {"id":"faq-6","question":"How was Istio started?","answer":"The Istio project was started by teams from Google and IBM in partnership with the Envoy team from Lyft. It’s been developed fully in the open on GitHub."},
  {"id":"faq-7","question":"What deployment environments are supported?","answer":"Istio is designed to be platform-independent, initially focused on Kubernetes. For our 1.18 release, Istio supports environments running Kubernetes (1.24, 1.25, 1.26, 1.27)."},
  {"id":"faq-8","question":"How can I contribute?","answer":"Contributions are highly welcome. We look forward to community feedback, additions, and bug reports.\n\nThe code repositories are hosted on GitHub. Please see our Contribution Guidelines to learn how to contribute.\n\nIn addition to the code, there are other ways to contribute to the Istio community, including on our discussion forum, Slack, and Stack Overflow."},
  {"id":"faq-9","question":"Where is the documentation?","answer":"Check out the documentation right here on istio.io. The docs include concept overviews, task guides, examples, and the complete reference documentation.\n\nDetailed developer-level documentation is maintained on our Wiki"},
  {"id":"faq-10","question":"Kubernetes - How can I debug problems with automatic sidecar injection?","answer":"Ensure that your cluster has met the prerequisites for the automatic sidecar injection. If your microservice is deployed in kube-system, kube-public or istio-system namespaces, they are exempted from automatic sidecar injection. Please use a different namespace instead."},
  {"id":"faq-11","question":"Can I enable mutual TLS for some services while leaving it disabled for other services in the same cluster?","answer":"Authentication policy can be mesh-wide (which affects all services in the mesh), namespace-wide (all services in the same namespace), or service specific. You can have policy or policies to set up mutual TLS for services in a cluster in any way as you want."},
  {"id":"faq-12","question":"How can I verify that traffic is using mutual TLS encryption?","answer":"If you installed Istio with values.global.proxy.privileged=true, you can use tcpdump to determine encryption status. Also in Kubernetes 1.23 and later, as an alternative to installing Istio as privileged, you can use kubectl debug to run tcpdump in an ephemeral container. See Istio mutual TLS migration for instructions."},
  {"id":"faq-13","question":"How does distributed tracing work with Istio?","answer":"Istio integrates with distributed tracing systems using Envoy-based tracing. With Envoy-based tracing integration, applications are responsible for forwarding tracing headers for subsequent outgoing requests.\n\nYou can find additional information in the Istio Distributed Tracing (Jaeger, Lightstep, Zipkin) Tasks and in the Envoy tracing docs."},
  {"id":"faq-14","question":"How can I view the current route rules I have configured with Istio?","answer":"Rules can be viewed using kubectl get virtualservice -o yaml"}
]
